---
layout: post
title: "A Tour of C++"
---

## Preface


## 1 The Basics

* Most readers will find useful tutorial and overview videos from conferences such as **CppCon** and **Meeting C++**. For technical details of the language and library offered by the ISO C++ standard, I recommend **[Cppreference]**.
* More advice about what constitutes good modern C++ can be found in the **C++ Core Guidelines** [Stroustrup,2015].
* troff: (**T**ypesetting **R**un**OFF**) A Unix utility that formats documents for typesetters and laser printers. Using a text editor, troff codes are embedded into the text and the troff command converts the document into the required output. 
* When we talk about portability of C++ programs, we usually mean portabilify of **source code**; that is, the source code can be successfully compiled and run on a variety of systems.
* The ISO C++ standard defines two kinds of entities:
    * *Core language features*, such as built-in types (e.g., `char` and `int`) and loops (e.g., `for`-statements and `while`-statements)
    * *Standard-library components*, such as containers (e.g., `vector` and `map`) and I/O operations (e.g., `<<` and `getline()`)
* C++ is a statically typed language. That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use. The type of an object determines **the set of operations** applicable to it and its **layout in memory**.

* A nonzero value from `main()` indicates **failure**.

* The operator `<<` (**"put to"**) writes its second argument onto its first.

* A string literal is a sequence of characters surrounded by double quotes.

* The value of such compile-time checking and type conversion should not be underestimated.

* If two alternative functions could be called, but neither is better than the other, the call is deemed ambiguous and the compiler gives an error. For example:

```c
void print(int, double);
void print(double, int);

void user2()
{
    print(0,0);     // error: ambiguous
}
```

* A *declaration* is a statement that introduces an entity into the program and specifies its type:
    * A *type* defines a set of possible values and a set of operations (for an object).
    * An *object* is some memory that holds a value of some type.    
    * A *value* is a set of bits interpreted according to a type.
    * A *variable* is a named object.

* To make long literals more readable for humans, we can use a single quote(') as a digit separator. For example, $\pi$ is about **3.14159'26535'89793'23846'26433'83279'50288** or if you prefer hexadecimal notation **0x3.243F'6A88'85A3'08D3**.

* The `=` form is tradtional and dates back to C, but if in doubt, use the general `{}`-list form. If nothing else, it saves you from conversion that lose information.
```c
int i1= 7.8;    // i1 becomes 7 (surprise?)
int i2 {7.8};   // error: floating-point to integer conversion
```
Unfortunately, conversions that lose information, *narrowing conversions*, such as `double` to `int` and `int` to `char`, are allowed and implicitly applied when you use `=` (but not when you use `{}`). The problems caused by implicit narrowing conversions are a price paid for C compatibility.

* We use `auto` where we don't have a specific reason to mention the type explicity. "Specific reaons" include:
    * The definition is in a large scope where we want to make the type clearly visible to readers of our code.
    * The type of the initializer isn't obvious.
    * We want to be explicit about a variable's range or precision (e.g., `double` rather than `float`).

* An object created by `new` "lives" until destroyed by `delete`.

* A `constexpr` function can be used for non-const arguments, but when that is done the result is not a constant expression. We allow a `constexpr` function to be called with non-const-expression arguments in contets that do not require constant expressions. That way, we don't have to define essentially the same function twice: once for constant expressions and once for variables. When we want a function to be used only for evaluation at compile time, we declare it `consteval` rather than `constexpr`.






## 2 User-Defined Types                                              
                                                                     
## 3 Modularity                                                      
                                                                     
## 4 Error Handling

## 5 Classes

## 6 Esssential Operations

## 7 Templates

## 8 Concepts and Generic Programming

## 9 Library Overview

## 10 Strings and Regular Experience

## 11 Input and Output

## 12 Containers

## 13 Algorithms

## 14 Ranges

## 15 Pointers and Containers

## 16 Utilities

## 17 Numbers

## 18 Concurrency

## 19 History and Compatibility

## Module std



