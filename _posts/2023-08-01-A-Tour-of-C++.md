---
layout: post
title: "A Tour of C++"
---

## Preface


## 1 The Basics

* Most readers will find useful tutorial and overview videos from conferences such as **CppCon** and **Meeting C++**. For technical details of the language and library offered by the ISO C++ standard, I recommend **[Cppreference]**.
* More advice about what constitutes good modern C++ can be found in the **C++ Core Guidelines** [Stroustrup,2015].
* troff: (**T**ypesetting **R**un**OFF**) A Unix utility that formats documents for typesetters and laser printers. Using a text editor, troff codes are embedded into the text and the troff command converts the document into the required output. 
* When we talk about portability of C++ programs, we usually mean portabilify of **source code**; that is, the source code can be successfully compiled and run on a variety of systems.
* The ISO C++ standard defines two kinds of entities:
    * *Core language features*, such as built-in types (e.g., `char` and `int`) and loops (e.g., `for`-statements and `while`-statements)
    * *Standard-library components*, such as containers (e.g., `vector` and `map`) and I/O operations (e.g., `<<` and `getline()`)
* C++ is a statically typed language. That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use. The type of an object determines **the set of operations** applicable to it and its **layout in memory**.

* A nonzero value from `main()` indicates **failure**.

* The operator `<<` (**"put to"**) writes its second argument onto its first.
    * `<<` output operator ("put to")
    * `>>` input operator ("get from")

* A string literal is a sequence of characters surrounded by double quotes.

* The value of such compile-time checking and type conversion should not be underestimated.

* If two alternative functions could be called, but neither is better than the other, the call is deemed ambiguous and the compiler gives an error. For example:

```c
void print(int, double);
void print(double, int);

void user2()
{
    print(0,0);     // error: ambiguous
}
```

* A *declaration* is a statement that introduces an entity into the program and specifies its type:
    * A *type* defines a set of possible values and a set of operations (for an object).
    * An *object* is some memory that holds a value of some type.    
    * A *value* is a set of bits interpreted according to a type.
    * A *variable* is a named object.

* To make long literals more readable for humans, we can use a single quote(') as a digit separator. For example, $\pi$ is about **3.14159'26535'89793'23846'26433'83279'50288** or if you prefer hexadecimal notation **0x3.243F'6A88'85A3'08D3**.

* The `=` form is tradtional and dates back to C, but if in doubt, use the general `{}`-list form. If nothing else, it saves you from conversion that lose information.
```c
int i1= 7.8;    // i1 becomes 7 (surprise?)
int i2 {7.8};   // error: floating-point to integer conversion
```
Unfortunately, conversions that lose information, *narrowing conversions*, such as `double` to `int` and `int` to `char`, are allowed and implicitly applied when you use `=` (but not when you use `{}`). The problems caused by implicit narrowing conversions are a price paid for C compatibility.

* We use `auto` where we don't have a specific reason to mention the type explicity. "Specific reaons" include:
    * The definition is in a large scope where we want to make the type clearly visible to readers of our code.
    * The type of the initializer isn't obvious.
    * We want to be explicit about a variable's range or precision (e.g., `double` rather than `float`).

* An object created by `new` "lives" until destroyed by `delete`.

* A `constexpr` function can be used for non-const arguments, but when that is done the result is not a constant expression. We allow a `constexpr` function to be called with non-const-expression arguments in contets that do not require constant expressions. That way, we don't have to define essentially the same function twice: once for constant expressions and once for variables. When we want a function to be used only for evaluation at compile time, we declare it `consteval` rather than `constexpr`.

* In declarations, 
    * `[ ]` means "array of"
    * `*` means "point to"

* In an expression,
    * prefix unary `*` means "contents of"
    * prefix unary `&` means "address of"

* In a declaration,
    * the unary suffix `&` means "reference to"

* A reference is similar to a pointer, except that
    * you don't need to use a prefix `*` to access the value refered to by the reference
    * Also, a reference cannot be made to refer to different object after its initialization.

* A reference and a pointer both refer/point to an object and both are represented in memory as a
machine address. However, the language rules for using them differ. Assignment to a reference
does not change what the reference refers to but assigns to the referenced object:

```c
int x = 2;
int y = 3;
int& r = x;     // r refers to x
int& r2 = y;    // r2 refers to y
r = r2;         // read through r2, write through r: x becomes 3
```
* To access the value pointed to by a pointer, you use ∗ ; that is implicitly done for a reference.

### 1.10 Advice
The advice here is a subset of the C++ Core Guidelines [Stroustrup,2015]. References to guide-
lines look like this [CG: ES.23], meaning the 23rd rule in the Expressions and Statement section.
Generally, a core guideline offers further rationale and examples.
* [1] Don’t panic! All will become clear in time; §1.1; [CG: In.0].
* [2] Don’t use the built-in features exclusively. Many fundamental (built-in) features are usually best used indirectly through libraries, such as the ISO C++ standard library (Chapters 9–18); [CG: P.13].
* [3] #include or (preferably) import the libraries needed to simplify programming; §1.2.1.
* [4] You don’t have to know every detail of C++ to write good programs.
* [5] Focus on programming techniques, not on language features.
* [6] The ISO C++ standard is the final word on language definition issues; §19.1.3; [CG: P.2].
* [7] ‘‘Package’’ meaningful operations as carefully named functions; §1.3; [CG: F.1].
* [8] A function should perform a single logical operation; §1.3 [CG: F.2].
* [9] Keep functions short; §1.3; [CG: F.3].
* [10] Use overloading when functions perform conceptually the same task on different types; §1.3.
* [11] If a function may have to be evaluated at compile time, declare it constexpr ; §1.6; [CG: F.4].
* [12] If a function must be evaluated at compile time, declare it consteval ; §1.6.
* [13] If a function may not have side effects, declare it constexpr or consteval ; §1.6; [CG: F.4].
* [14] Understand how language primitives map to hardware; §1.4, §1.7, §1.9, §2.3, §5.2.2, §5.4.
* [15] Use digit separators to make large literals readable; §1.4; [CG: NL.11].
* [16] Avoid complicated expressions; [CG: ES.40].
* [17] Avoid narrowing conversions; §1.4.2; [CG: ES.46].
* [18] Minimize the scope of a variable; §1.5, §1.8.
* [19] Keep scopes small; §1.5; [CG: ES.5].
* [20] Avoid ‘‘magic constants’’; use symbolic constants; §1.6; [CG: ES.45].
* [21] Prefer immutable data; §1.6; [CG: P.10].
* [22] Declare one name (only) per declaration; [CG: ES.10].
* [23] Keep common and local names short; keep uncommon and nonlocal names longer; [CG: ES.7].
* [24] Avoid similar-looking names; [CG: ES.8].
* [25] Avoid ALL_CAPS names; [CG: ES.9].
* [26] Prefer the {} -initializer syntax for declarations with a named type; §1.4; [CG: ES.23].
* [27] Use auto to avoid repeating type names; §1.4.2; [CG: ES.11].
* [28] Avoid uninitialized variables; §1.4; [CG: ES.20].
* [29] Don’t declare a variable until you have a value to initialize it with; §1.7, §1.8; [CG: ES.21].
* [30] When declaring a variable in the condition of an if -statement, prefer the version with the
* implicit test against 0 or nullptr ; §1.8.
* [31] Prefer range- for loops over for -loops with an explicit loop variable; §1.7.
* [32] Use unsigned for bit manipulation only; §1.4; [CG: ES.101] [CG: ES.106].
* [33] Keep use of pointers simple and straightforward; §1.7; [CG: ES.42].
* [34] Use nullptr rather than 0 or NULL ; §1.7; [CG: ES.47].


## 2 User-Defined Types                                              
                                                                     
## 3 Modularity                                                      
                                                                     
## 4 Error Handling

## 5 Classes

## 6 Esssential Operations

## 7 Templates

## 8 Concepts and Generic Programming

## 9 Library Overview

## 10 Strings and Regular Experience

## 11 Input and Output

## 12 Containers

## 13 Algorithms

## 14 Ranges

## 15 Pointers and Containers

## 16 Utilities

## 17 Numbers

## 18 Concurrency

## 19 History and Compatibility

## Module std



